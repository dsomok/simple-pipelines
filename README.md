| This documentation was generated by the GPT-4 model |
|-----------------------------------------------------|

<br/>

# Pipeline Library

This library provides a simple and efficient way to create and execute middleware pipelines in .NET. It supports middleware, filters, and custom context types.

## Getting Started
This library consists of a few key interfaces and classes that work together to create a pipeline of middleware with optional filters.

## Interfaces

### IPipelineBuilder

The `IPipelineBuilder` interface defines the methods for constructing a pipeline.

```csharp
public interface IPipelineBuilder<TContext, TResult>
    where TContext : IPipelineContext<TResult>
{
    IPipelineBuilder<TContext, TResult> Use(Type middlewareType);

    IPipelineBuilder<TContext, TResult> Use<TMiddleware>()
        where TMiddleware : class, IPipelineMiddleware<TContext>;

    IPipelineBuilder<TContext, TResult> UseFilter<TFilter>()
        where TFilter : class, IPipelineFilter;

    Pipeline<TContext, TResult> Build();
}
```

### IPipelineContext

The `IPipelineContext` interface defines the methods for managing the result of the pipeline.

```csharp
public interface IPipelineContext<TResult>
{
    Task<bool> IsValid();
    Task<TResult> GetResult();
}
```

### IPipelineFilter

The `IPipelineFilter` interface defines the methods for handling events during the middleware execution.

```csharp
public interface IPipelineFilter
{
    Task OnMiddlewareExecuting<TContext>(IPipelineMiddleware<TContext> middleware, TContext context);

    Task OnMiddlewareExecuted<TContext>(IPipelineMiddleware<TContext> middleware, TContext context);

    Task OnMiddlewareError<TContext>(IPipelineMiddleware<TContext> middleware, TContext context, Exception ex);
}
```

### IPipelineMiddleware

The `IPipelineMiddleware` interface defines the methods for processing the pipeline context.

```csharp
public interface IPipelineMiddleware<TContext>
{
    Task Execute(TContext context, Func<TContext, Task> next, CancellationToken cancellationToken);
}
```

## Pipeline<TContext, TResult>

The `Pipeline<TContext, TResult>` class represents a sequence of operations (middlewares) to be executed in a specific order. The pipeline processes a given context and produces a result of type TResult. The pipeline also works with optional filters that can be used to add cross-cutting concerns, such as logging or error handling.

As a user, you will typically use the `Execute` method to run the pipeline with a specific context. The pipeline takes care of executing the middlewares in order, handling any exceptions, and interacting with the filters as needed. You don't need to worry about the internals of how the pipeline manages middlewares and filters, as it is abstracted away by the class.

## PipelineBuilder<TContext, TResult>

The `PipelineBuilder<TContext, TResult>` class provides a fluent interface for creating and configuring a pipeline. As a user, you will typically extend this abstract class to create your custom pipeline builder. The custom pipeline builder is responsible for defining the middlewares and filters used in the pipeline.

You will use the `Use` and `UseFilter` methods in your custom pipeline builder to add middlewares and filters to the pipeline. The `Build` method is then used to construct a `Pipeline<TContext, TResult>` instance, which can be executed with the desired context.

Here is an example of how you might use a custom pipeline builder:

1. Create a custom pipeline builder by extending the `PipelineBuilder<TContext, TResult>` class.
2. Implement the `PreparePipeline` method to configure the middlewares and filters you want to use.
3. Instantiate your custom pipeline builder and use the `Build` method to create a `Pipeline<TContext, TResult>` instance.
4. Execute the pipeline with a specific context using the `Execute` method.

This approach provides a clean, maintainable way to create and manage complex pipelines, making it easy to add, remove, or modify middlewares and filters as needed.

## Example Usage

Let's consider a real-world example where we want to implement an order processing pipeline. In this scenario, we'll have three middlewares: `ValidateOrderMiddleware`, `ApplyDiscountMiddleware`, and `CreateInvoiceMiddleware`. Additionally, we'll use a `LoggingFilter` to log the execution of each middleware.

Here's a sample implementation:

1. First, create the specific middlewares and filter:

```csharp
public class ValidateOrderMiddleware : IPipelineMiddleware<OrderProcessingContext>
{
    public async Task Execute(OrderProcessingContext context, Func<OrderProcessingContext, Task> next, CancellationToken cancellationToken)
    {
        // Validate the order (e.g., check stock availability, customer data, etc.)
        // ...

        // Proceed to the next middleware in the pipeline
        await next(context);
    }
}

public class ApplyDiscountMiddleware : IPipelineMiddleware<OrderProcessingContext>
{
    public async Task Execute(OrderProcessingContext context, Func<OrderProcessingContext, Task> next, CancellationToken cancellationToken)
    {
        // Apply any applicable discounts to the order
        // ...

        // Proceed to the next middleware in the pipeline
        await next(context);
    }
}

public class CreateInvoiceMiddleware : IPipelineMiddleware<OrderProcessingContext>
{
    public async Task Execute(OrderProcessingContext context, Func<OrderProcessingContext, Task> next, CancellationToken cancellationToken)
    {
        // Create an invoice for the order
        // ...

        // Proceed to the next middleware in the pipeline
        await next(context);
    }
}

public class LoggingFilter : IPipelineFilter
{
    public async Task OnMiddlewareExecuting<TContext>(IPipelineMiddleware<TContext> middleware, TContext context)
    {
        // Log middleware start
        Console.WriteLine($"Starting {middleware.GetType().Name}");
    }

    public async Task OnMiddlewareExecuted<TContext>(IPipelineMiddleware<TContext> middleware, TContext context)
    {
        // Log middleware completion
        Console.WriteLine($"Completed {middleware.GetType().Name}");
    }

    public async Task OnMiddlewareError<TContext>(IPipelineMiddleware<TContext> middleware, TContext context, Exception ex)
    {
        // Log middleware error
        Console.WriteLine($"Error in {middleware.GetType().Name}: {ex.Message}");
    }
}
```

2. Create the context class:

```csharp
public class OrderProcessingContext : IPipelineContext<bool>
{
    // Add properties related to the order processing, e.g., the order, customer, etc.
    // ...

    public async Task<bool> IsValid()
    {
        // Implement validation logic
        // ...

        return true;
    }

    public async Task<bool> GetResult()
    {
        // Return the result of the order processing (e.g., success or failure)
        return true;
    }
}
```

3. Create a custom pipeline builder:

```csharp
public class OrderProcessingPipelineBuilder : PipelineBuilder<OrderProcessingContext, bool>
{
    public OrderProcessingPipelineBuilder(IServiceProvider serviceProvider)
        : base(serviceProvider)
    {
    }

    protected override IPipelineBuilder<OrderProcessingContext, bool> PreparePipeline()
    {
        return this
            .Use<ValidateOrderMiddleware>()
            .Use<ApplyDiscountMiddleware>()
            .Use<CreateInvoiceMiddleware>()
            .UseFilter<LoggingFilter>();
    }
}
```

4. Instantiate the custom pipeline builder, build the pipeline, and execute it:

```csharp
// Setup dependency injection
var services = new ServiceCollection();
services.AddPipelineMiddlewares(typeof(ValidateOrderMiddleware).Assembly);
services.AddPipelineMiddlewareFilters(typeof(LoggingFilter).Assembly);
services.AddSingleton<OrderProcessingPipelineBuilder>();
var serviceProvider = services.BuildServiceProvider();

// Instantiate the custom pipeline builder
var pipelineBuilder = serviceProvider.GetRequiredService<OrderProcessingPipelineBuilder>();

// Build the pipeline
var pipeline = pipelineBuilder.Build();

// Create a context for the order processing
var orderProcessingContext = new OrderProcessingContext
{
    // Initialize the context with order, customer data, etc.
    // ...
};

// Execute the pipeline
try
{
    CancellationToken cancellationToken = CancellationToken.None;
    var result = await pipeline.Execute(orderProcessingContext, cancellationToken);

    if (result)
    {
        Console.WriteLine("Order processing completed successfully.");
    }
    else
    {
        Console.WriteLine("Order processing failed.");
    }
}
catch (Exception ex)
{
    Console.WriteLine($"Order processing encountered an error: {ex.Message}");
}
```

In this example, we've created an order processing pipeline with three middlewares for validating orders, applying discounts, and creating invoices. We've also added a logging filter to log the execution of each middleware. The pipeline is built and executed using the custom `OrderProcessingPipelineBuilder` class. The pipeline processes the order encapsulated in the `OrderProcessingContext` and returns a success or failure result.